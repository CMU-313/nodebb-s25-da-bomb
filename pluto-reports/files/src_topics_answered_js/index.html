<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - src/topics/answered.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/topics/answered.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">183</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">42.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.50</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const _ = require(&#039;lodash&#039;);

const db = require(&#039;../database&#039;);
const user = require(&#039;../user&#039;);
const categories = require(&#039;../categories&#039;);
const privileges = require(&#039;../privileges&#039;);
const plugins = require(&#039;../plugins&#039;);


module.exports = function (Topics) {
	Topics.markAsAnswered = async function (uid, tid) {
		const topicData = await Topics.getTopicFields(tid, [&#039;answered&#039;]);
		if (!topicData || !topicData.cid) {
			throw new Error(&#039;[[error:no-topic]]&#039;);
		}
		// function from ../data.js
		await Topics.setTopicField(tid, &#039;answered&#039;, 1);
		plugins.hooks.fire(&#039;action:topic.answered&#039;, { tid: tid, uid: uid });
		return topicData;
	};
	Topics.markAsUnanswered = async function (uid, tid) {
		const topicData = await Topics.getTopicFields(tid, [&#039;answered&#039;]);
		if (!topicData || !topicData.cid) {
			throw new Error(&#039;[[error:no-topic]]&#039;);
		}

		await Topics.setTopicField(tid, &#039;answered&#039;, 0);
		plugins.hooks.fire(&#039;action:topic.answered&#039;, { tid: tid, uid: uid });
		return topicData;
	};
	// based on getUnread functions from ../unread.js
	Topics.getUnansweredTopics = async function (params) {
		const unansweredTopics = {
			showSelect: true,
			nextStart: 0,
			topics: [],
		};
		let tids = await Topics.getUnansweredTids(params);
		unansweredTopics.topicCount = tids.length;

		if (!tids.length) {
			return unansweredTopics;
		}

		tids = tids.slice(params.start, params.stop !== -1 ? params.stop + 1 : undefined);

		const topicData = await Topics.getTopicsByTids(tids, params.uid);
		if (!topicData.length) {
			return unansweredTopics;
		}
		Topics.calculateTopicIndices(topicData, params.start);
		unansweredTopics.topics = topicData;
		unansweredTopics.nextStart = params.stop + 1;
		return unansweredTopics;
	};
	Topics.getUnAnsweredTids = async function (params) {
		const results = await Topics.getAnsweredData(params);
		return params.count ? results.counts : results.tids;
	};
	Topics.getAnsweredData = async function (params) {
		const uid = parseInt(params.uid, 10);

		params.filter = params.filter || &#039;&#039;;

		if (params.cid &amp;&amp; !Array.isArray(params.cid)) {
			params.cid = [params.cid];
		}

		if (params.tag &amp;&amp; !Array.isArray(params.tag)) {
			params.tag = [params.tag];
		}

		const data = await getTids(params);
		if (uid &lt;= 0) {
			return data;
		}

		const result = await plugins.hooks.fire(&#039;filter:topics.getAnsweredTids&#039;, {
			uid: uid,
			tids: data.tids,
			counts: data.counts,
			tidsByFilter: data.tidsByFilter,
			answeredCids: data.answeredCids,
			cid: params.cid,
			filter: params.filter,
			query: params.query || {},
		});
		return result;
	};
	// from unread.js
	async function getTids(params) {
		const counts = { &#039;&#039;: 0, new: 0, watched: 0, unreplied: 0 };
		const tidsByFilter = { &#039;&#039;: [], new: [], watched: [], unreplied: [] };
		const unreadCids = [];
		if (params.uid &lt;= 0) {
			return { counts, tids: [], tidsByFilter, unreadCids };
		}

		params.cutoff = await Topics.unreadCutoff(params.uid);

		const [followedTids, userScores, tids_unread] = await Promise.all([
			getFollowedTids(params),
			db.getSortedSetRevRangeByScoreWithScores(`uid:${params.uid}:tids_read`, 0, -1, &#039;+inf&#039;, params.cutoff),
			db.getSortedSetRevRangeWithScores(`uid:${params.uid}:tids_unread`, 0, -1),
		]);

		const userReadTimes = _.mapValues(_.keyBy(userScores, &#039;value&#039;), &#039;score&#039;);
		const isTopicsFollowed = {};
		followedTids.forEach((t) =&gt; {
			isTopicsFollowed[t.value] = true;
		});
		const unreadFollowed = await db.isSortedSetMembers(
			`uid:${params.uid}:followed_tids`, tids_unread.map(t =&gt; t.value)
		);

		tids_unread.forEach((t, i) =&gt; {
			isTopicsFollowed[t.value] = unreadFollowed[i];
		});

		const unreadTopics = followedTids;
		const blockedUids = await user.blocks.list(params.uid);
		let tids = _.uniq(unreadTopics.map(topic =&gt; topic.value)).slice(0, 200);

		tids = await privileges.topics.filterTids(&#039;topics:read&#039;, tids, params.uid);
		const topicData = (await Topics.getTopicsFields(tids, [&#039;tid&#039;, &#039;cid&#039;, &#039;uid&#039;, &#039;postcount&#039;, &#039;deleted&#039;, &#039;scheduled&#039;, &#039;tags&#039;]))
			.filter(t =&gt; t.scheduled || !t.deleted);
		const topicCids = _.uniq(topicData.map(topic =&gt; topic.cid)).filter(Boolean);

		const categoryWatchState = await categories.getWatchState(topicCids, params.uid);
		const userCidState = _.zipObject(topicCids, categoryWatchState);

		const filterCids = params.cid &amp;&amp; params.cid.map(cid =&gt; parseInt(cid, 10));
		const filterTags = params.tag &amp;&amp; params.tag.map(tag =&gt; String(tag));

		topicData.forEach((topic) =&gt; {
			if (topic &amp;&amp; topic.cid &amp;&amp;
				(!filterCids || filterCids.includes(topic.cid)) &amp;&amp;
				(!filterTags || filterTags.every(tag =&gt; topic.tags.find(topicTag =&gt; topicTag.value === tag))) &amp;&amp;
				!blockedUids.includes(topic.uid)) {
				if (isTopicsFollowed[topic.tid] ||
					[categories.watchStates.watching, categories.watchStates.tracking].includes(userCidState[topic.cid])) {
					tidsByFilter[&#039;&#039;].push(topic.tid);
					unreadCids.push(topic.cid);
				}

				if (isTopicsFollowed[topic.tid]) {
					tidsByFilter.watched.push(topic.tid);
				}

				if (topic.postcount &lt;= 1) {
					tidsByFilter.unreplied.push(topic.tid);
				}

				if (!userReadTimes[topic.tid]) {
					tidsByFilter.new.push(topic.tid);
				}
			}
		});

		counts[&#039;&#039;] = tidsByFilter[&#039;&#039;].length;
		counts.watched = tidsByFilter.watched.length;
		counts.unreplied = tidsByFilter.unreplied.length;
		counts.new = tidsByFilter.new.length;

		return {
			counts: counts,
			tids: tidsByFilter[params.filter],
			tidsByFilter: tidsByFilter,
			unreadCids: unreadCids,
		};
	}
	async function getFollowedTids(params) {
		const keys = params.cid ?
			params.cid.map(cid =&gt; `cid:${cid}:tids:lastposttime`) :
			&#039;topics:recent&#039;;

		const recentTopicData = await db.getSortedSetRevRangeByScoreWithScores(keys, 0, -1, &#039;+inf&#039;, params.cutoff);
		const isFollowed = await db.isSortedSetMembers(`uid:${params.uid}:followed_tids`, recentTopicData.map(t =&gt; t.tid));
		return recentTopicData.filter((t, i) =&gt; isFollowed[i]);
	}
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
